<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>화면 공유 뷰어</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --primary-hover: #45a049;
            --secondary-color: #2196F3;
            --secondary-hover: #0b7dda;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --background-color: #f5f5f5;
            --card-color: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content {
            display: flex;
            flex: 1;
        }
        
        .sidebar {
            width: 320px;
            background-color: var(--card-color);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            transition: transform 0.3s;
            z-index: 10;
        }
        
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                height: 100%;
                transform: translateX(-100%);
            }
            
            .sidebar.visible {
                transform: translateX(0);
            }
        }
        
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #000;
            position: relative;
            overflow: hidden;
        }
        
        h1, h2 {
            margin-bottom: 15px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            transition: background-color 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            background-color: var(--primary-hover);
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        button.secondary {
            background-color: var(--secondary-color);
        }
        
        button.secondary:hover {
            background-color: var(--secondary-hover);
        }
        
        button.danger {
            background-color: var(--danger-color);
        }
        
        button.danger:hover {
            background-color: #d32f2f;
        }
        
        .alert {
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            border-left: 4px solid transparent;
        }
        
        .alert.warning {
            background-color: #fff3cd;
            border-color: var(--warning-color);
            color: #856404;
        }
        
        .alert.danger {
            background-color: #f8d7da;
            border-color: var(--danger-color);
            color: #721c24;
        }
        
        .alert.success {
            background-color: #d4edda;
            border-color: var(--primary-color);
            color: #155724;
        }
        
        .code-box {
            background-color: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
            margin-bottom: 15px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .short-code {
            font-size: 32px;
            letter-spacing: 4px;
        }
        
        .status {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f9fa;
            margin-top: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .status-disconnected .status-indicator {
            background-color: var(--danger-color);
        }
        
        .status-connecting .status-indicator {
            background-color: var(--warning-color);
            animation: pulse 1.5s infinite;
        }
        
        .status-connected .status-indicator {
            background-color: var(--primary-color);
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
        }
        
        .btn-group button {
            flex: 1;
        }
        
        .screen-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            position: relative;
            overflow: hidden;
        }
        
        .screen-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #screenDisplay {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .toolbar {
            background-color: rgba(0, 0, 0, 0.7);
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
            transition: opacity 0.3s;
            opacity: 0;
        }
        
        .screen-container:hover .toolbar {
            opacity: 1;
        }
        
        .control-button {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            width: auto;
        }
        
        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .stats-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            transition: opacity 0.3s;
            opacity: 0;
        }
        
        .screen-container:hover .stats-panel {
            opacity: 1;
        }
        
        .hidden {
            display: none !important;
        }
        
        .mt-10 {
            margin-top: 10px;
        }
        
        .mt-20 {
            margin-top: 20px;
        }
        
        hr {
            border: 0;
            height: 1px;
            background-color: var(--border-color);
            margin: 20px 0;
        }
        
        .toggle-sidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border: none;
            width: auto;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .log-container {
            margin-top: 20px;
            height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: #f8f9fa;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
        }
        
        .log-entry {
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding-bottom: 2px;
        }
        
        .log-time {
            color: #666;
            margin-right: 8px;
        }
        
        .log-error {
            color: var(--danger-color);
        }
        
        .log-warning {
            color: var(--warning-color);
        }
        
        .log-success {
            color: var(--primary-color);
        }
        
        .quality-options {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-top: 15px;
        }
        
        .quality-options h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .connection-waiting {
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>화면 공유 뷰어</h1>
    </div>
    
    <div class="content">
        <div class="sidebar" id="sidebar">
            <div id="protocolAlert" class="alert warning hidden">
                <strong>주의!</strong> 현재 HTTP 환경에서 실행 중입니다. 보안을 위해 HTTPS 환경에서 사용하는 것이 좋습니다.
            </div>
            
            <h2>연결 설정</h2>
            
            <div class="form-group">
                <label for="clientCode">클라이언트 코드 입력:</label>
                <input type="text" id="clientCode" placeholder="4자리 코드 입력" autocomplete="off">
            </div>
            
            <button id="connectBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5z"/>
                </svg>
                연결하기
            </button>
            
            <div id="connectionArea" class="hidden">
                <hr>
                
                <div class="form-group">
                    <label>내 뷰어 코드:</label>
                    <div id="myCode" class="code-box short-code">----</div>
                    <button id="copyMyCodeBtn" class="secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
                            <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                        </svg>
                        코드 복사
                    </button>
                </div>
                
                <div id="connectionStatus" class="status status-disconnected">
                    <div class="status-indicator"></div>
                    <div class="status-text">연결 대기 중</div>
                </div>
                
                <div class="quality-options">
                    <h3>화면 품질 설정</h3>
                    
                    <div class="form-group">
                        <label for="captureQuality">이미지 품질:</label>
                        <select id="captureQuality">
                            <option value="0.6">저화질 (빠름)</option>
                            <option value="0.8" selected>중화질</option>
                            <option value="0.9">고화질 (느림)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="captureRate">캡처 간격:</label>
                        <select id="captureRate">
                            <option value="100">매우 빠름 (100ms)</option>
                            <option value="200" selected>빠름 (200ms)</option>
                            <option value="500">중간 (500ms)</option>
                            <option value="1000">느림 (1000ms)</option>
                        </select>
                    </div>
                    
                    <button id="applySettingsBtn" class="secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
                        </svg>
                        설정 적용
                    </button>
                </div>
                
                <button id="disconnectBtn" class="danger mt-20">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383z"/>
                        <path d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708-.708L9.793 8H1.5a.5.5 0 0 1 0-1h8.293L7.646 4.854a.5.5 0 0 1 0-.708z"/>
                    </svg>
                    연결 끊기
                </button>
            </div>
            
            <hr class="mt-20">
            
            <h3>상세 로그</h3>
            <div id="logContainer" class="log-container"></div>
        </div>
        
        <div class="main-area">
            <button id="toggleSidebarBtn" class="toggle-sidebar hidden">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M4.5 11.5A.5.5 0 0 1 5 11h9a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm2 4A.5.5 0 0 1 5 11h9a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/>
                </svg>
            </button>
            
            <div class="screen-area">
                <div id="waitingMessage" class="connection-waiting">
                    <h2>연결 대기 중</h2>
                    <p>클라이언트 코드를 입력하고 연결 버튼을 눌러주세요.</p>
                </div>
                
                <div id="loadingMessage" class="loading hidden">
                    <div class="spinner"></div>
                    <p>화면 데이터 수신 중...</p>
                </div>
                
                <div id="screenContainer" class="screen-container hidden">
                    <img id="screenDisplay" alt="공유된 화면">
                    
                    <div class="stats-panel" id="statsPanel">
                        <div>프레임 크기: <span id="frameSize">0</span> KB</div>
                        <div>프레임 속도: <span id="frameRate">0</span> fps</div>
                        <div>지연 시간: <span id="latency">0</span> ms</div>
                    </div>
                    
                    <div class="toolbar">
                        <button class="control-button" id="fullscreenBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
                            </svg>
                            전체화면
                        </button>
                        
                        <button class="control-button" id="refreshBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/>
                                <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.1z"/>
                            </svg>
                            새로고침
                        </button>
                        
                        <button class="control-button" id="settingsBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
                            </svg>
                            설정
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // DOM 요소
        const protocolAlert = document.getElementById('protocolAlert');
        const clientCodeInput = document.getElementById('clientCode');
        const connectBtn = document.getElementById('connectBtn');
        const connectionArea = document.getElementById('connectionArea');
        const myCodeElement = document.getElementById('myCode');
        const copyMyCodeBtn = document.getElementById('copyMyCodeBtn');
        const connectionStatus = document.getElementById('connectionStatus');
        const statusIndicator = connectionStatus.querySelector('.status-indicator');
        const statusText = connectionStatus.querySelector('.status-text');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const waitingMessage = document.getElementById('waitingMessage');
        const loadingMessage = document.getElementById('loadingMessage');
        const screenContainer = document.getElementById('screenContainer');
        const screenDisplay = document.getElementById('screenDisplay');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
        const sidebar = document.getElementById('sidebar');
        const captureQualitySelect = document.getElementById('captureQuality');
        const captureRateSelect = document.getElementById('captureRate');
        const applySettingsBtn = document.getElementById('applySettingsBtn');
        const logContainer = document.getElementById('logContainer');
        const statsPanel = document.getElementById('statsPanel');
        const frameSizeElement = document.getElementById('frameSize');
        const frameRateElement = document.getElementById('frameRate');
        const latencyElement = document.getElementById('latency');
        
        // 상수
        const STUN_SERVERS = [
            'stun:stun.l.google.com:19302',
            'stun:stun1.l.google.com:19302',
            'stun:stun2.l.google.com:19302',
            'stun:stun3.l.google.com:19302',
            'stun:stun4.l.google.com:19302'
        ];
        
        // 설정
        const ICE_CONFIG = {
            iceServers: STUN_SERVERS.map(url => ({ urls: url })),
            iceCandidatePoolSize: 10
        };
        
        // 전역 변수
        let peerConnection = null;
        let dataChannel = null;
        let isConnected = false;
        let myCode = '';
        let pendingCandidates = [];
        let frameCount = 0;
        let lastFrameTime = 0;
        let calculatedFps = 0;
        let fpsUpdateInterval = null;
        let pingInterval = null;
        let lastPingTime = 0;
        
        // 모바일 여부 확인
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // 로그 기록 함수
        function log(message, type = 'info') {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('ko-KR', { hour12: false });
            
            // 콘솔에 로그 출력
            if (type === 'error') {
                console.error(`[${timeStr}] ${message}`);
            } else if (type === 'warning') {
                console.warn(`[${timeStr}] ${message}`);
            } else {
                console.log(`[${timeStr}] ${message}`);
            }
            
            // UI에 로그 추가
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry${type !== 'info' ? ` log-${type}` : ''}`;
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = timeStr;
            
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            
            logEntry.appendChild(timeSpan);
            logEntry.appendChild(messageSpan);
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // HTTPS 검사
        function checkProtocol() {
            const isSecure = window.location.protocol === 'https:' || 
                            window.location.hostname === 'localhost' || 
                            window.location.hostname === '127.0.0.1';
            
            if (!isSecure) {
                protocolAlert.classList.remove('hidden');
                log('HTTP 환경에서 실행 중입니다. 일부 기능이 제한될 수 있습니다.', 'warning');
            }
            
            return isSecure;
        }
        
        // 4자리 코드 생성
        function generateShortCode() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }
        
        // 연결 상태 업데이트
        function updateConnectionStatus(state, message = null) {
            connectionStatus.className = `status status-${state}`;
            
            switch (state) {
                case 'connecting':
                    statusText.textContent = message || '연결 중...';
                    waitingMessage.classList.add('hidden');
                    loadingMessage.classList.remove('hidden');
                    screenContainer.classList.add('hidden');
                    break;
                case 'connected':
                    statusText.textContent = message || '연결됨';
                    waitingMessage.classList.add('hidden');
                    loadingMessage.classList.add('hidden');
                    screenContainer.classList.remove('hidden');
                    toggleSidebarBtn.classList.remove('hidden');
                    
                    // 모바일인 경우 사이드바 숨기기
                    if (isMobile) {
                        sidebar.classList.remove('visible');
                    }
                    break;
                case 'disconnected':
                    statusText.textContent = message || '연결 끊김';
                    waitingMessage.classList.remove('hidden');
                    loadingMessage.classList.add('hidden');
                    screenContainer.classList.add('hidden');
                    toggleSidebarBtn.classList.add('hidden');
                    
                    // 항상 사이드바 표시
                    sidebar.classList.add('visible');
                    break;
                default:
                    statusText.textContent = message || '연결 대기 중';
                    waitingMessage.classList.remove('hidden');
                    loadingMessage.classList.add('hidden');
                    screenContainer.classList.add('hidden');
                    toggleSidebarBtn.classList.add('hidden');
            }
        }
        
        // WebRTC 연결 설정
        function setupPeerConnection() {
            // 기존 연결 정리
            if (peerConnection) {
                peerConnection.close();
            }
            
            log('새 WebRTC 연결 설정 중...');
            
            // 새 연결 생성
            peerConnection = new RTCPeerConnection(ICE_CONFIG);
            
            // 데이터 채널 이벤트
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel(dataChannel);
            };
            
            // ICE 후보 수집 이벤트
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    log('ICE 후보 수집됨');
                    
                    // 상대가 연결되지 않았다면 후보 저장
                    if (!isConnected) {
                        pendingCandidates.push(event.candidate);
                    } else {
                        // 연결된 경우 바로 전송
                        sendSignalingMessage({
                            type: 'ice-candidate',
                            candidate: event.candidate
                        });
                    }
                }
            };
            
            // ICE 연결 상태 변경
            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE 연결 상태 변경: ${peerConnection.iceConnectionState}`);
                
                if (peerConnection.iceConnectionState === 'connected' || 
                    peerConnection.iceConnectionState === 'completed') {
                    isConnected = true;
                    updateConnectionStatus('connected');
                    startPingInterval();
                } else if (peerConnection.iceConnectionState === 'disconnected' || 
                          peerConnection.iceConnectionState === 'failed' ||
                          peerConnection.iceConnectionState === 'closed') {
                    isConnected = false;
                    updateConnectionStatus('disconnected', 
                        peerConnection.iceConnectionState === 'failed' ? '연결 실패' : '연결 끊김');
                    stopPingInterval();
                }
            };
            
            // 연결 설정 완료 시
            peerConnection.onsignalingstatechange = () => {
                log(`시그널링 상태 변경: ${peerConnection.signalingState}`);
            };
            
            return peerConnection;
        }
        
        // 데이터 채널 설정
        function setupDataChannel(channel) {
            channel.onopen = () => {
                log('데이터 채널이 열렸습니다.', 'success');
                
                // 연결 상태 업데이트
                isConnected = true;
                updateConnectionStatus('connected');
                
                // 실시간 통계 시작
                startFrameRateCalculation();
                startPingInterval();
            };
            
            channel.onclose = () => {
                log('데이터 채널이 닫혔습니다.', 'warning');
                isConnected = false;
                updateConnectionStatus('disconnected');
                stopFrameRateCalculation();
                stopPingInterval();
            };
            
            channel.onerror = (error) => {
                log(`데이터 채널 오류: ${error}`, 'error');
            };
            
            channel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleDataChannelMessage(message);
                } catch (err) {
                    log(`메시지 처리 오류: ${err.message}`, 'error');
                }
            };
        }
        
        // 데이터 채널 메시지 처리
        function handleDataChannelMessage(message) {
            switch (message.type) {
                case 'frame':
                    // 화면 프레임 처리
                    updateScreen(message.data);
                    // 통계 업데이트
                    updateFrameStats(message.data);
                    break;
                    
                case 'pong':
                    // 핑-퐁 지연시간 계산
                    if (lastPingTime > 0 && message.originalTimestamp === lastPingTime) {
                        const latency = Date.now() - lastPingTime;
                        latencyElement.textContent = latency;
                        lastPingTime = 0;
                    }
                    break;
            }
        }
        
        // 화면 업데이트
        function updateScreen(imgData) {
            // 첫 프레임인 경우 로딩 메시지 숨기기
            if (loadingMessage.classList.contains('hidden') === false) {
                loadingMessage.classList.add('hidden');
                screenContainer.classList.remove('hidden');
            }
            
            // 이미지 데이터 설정
            screenDisplay.src = imgData;
            
            // 프레임 카운터 증가
            frameCount++;
        }
        
        // 프레임 통계 업데이트
        function updateFrameStats(imgData) {
            // 데이터 크기 (KB)
            const sizeInKB = Math.round(imgData.length / 1024);
            frameSizeElement.textContent = sizeInKB;
        }
        
        // 프레임 속도 계산 시작
        function startFrameRateCalculation() {
            stopFrameRateCalculation();
            
            // 초기화
            frameCount = 0;
            lastFrameTime = Date.now();
            
            // 매 초마다 FPS 계산
            fpsUpdateInterval = setInterval(() => {
                const now = Date.now();
                const elapsed = (now - lastFrameTime) / 1000; // 초 단위 변환
                
                if (elapsed > 0) {
                    calculatedFps = Math.round(frameCount / elapsed);
                    frameRateElement.textContent = calculatedFps;
                    
                    // 리셋
                    frameCount = 0;
                    lastFrameTime = now;
                }
            }, 1000);
        }
        
        // 프레임 속도 계산 중지
        function stopFrameRateCalculation() {
            if (fpsUpdateInterval) {
                clearInterval(fpsUpdateInterval);
                fpsUpdateInterval = null;
            }
        }
        
        // 핑 인터벌 시작
        function startPingInterval() {
            stopPingInterval();
            
            pingInterval = setInterval(() => {
                if (dataChannel && dataChannel.readyState === 'open') {
                    lastPingTime = Date.now();
                    sendControlMessage({
                        type: 'ping',
                        timestamp: lastPingTime
                    });
                }
            }, 2000);
        }
        
        // 핑 인터벌 중지
        function stopPingInterval() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
            }
        }
        
        // 제어 메시지 전송
        function sendControlMessage(message) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(message));
            }
        }
        
        // 시그널링 메시지 전송 (WebRTC 연결 설정용)
        function sendSignalingMessage(message) {
            try {
                // WebRTC 시그널링 서버가 없으므로 UI로 메시지 전달
                // 실제 구현에서는 이 부분이 서버를 통해 전달되어야 함
                const clientCode = clientCodeInput.value.trim();
                
                if (!clientCode) {
                    log('클라이언트 코드가 입력되지 않았습니다.', 'warning');
                    return;
                }
                
                // 메시지에 식별 정보 추가
                const completeMessage = {
                    ...message,
                    sender: myCode,
                    receiver: clientCode,
                    timestamp: Date.now()
                };
                
                // 메시지 직렬화
                const serializedMessage = JSON.stringify(completeMessage);
                
                // 시뮬레이션된 시그널링 (보통 서버를 통해 이루어짐)
                simulateSignalingServer(serializedMessage);
                
                log(`시그널링 메시지 전송: ${message.type}`);
            } catch (err) {
                log(`시그널링 메시지 전송 오류: ${err.message}`, 'error');
            }
        }
        
        // 시뮬레이션된 시그널링 서버 (실제 구현에서는 실제 서버로 대체)
        function simulateSignalingServer(serializedMessage) {
            // 실제 구현에서는 이 부분이 웹소켓이나 HTTP로 서버와 통신하는 부분
            // 여기서는 상대방으로부터 응답을 받는 시뮬레이션만 함
            
            try {
                const message = JSON.parse(serializedMessage);
                
                // 클라이언트가 보낸 응답 메시지인 경우
                if (message.type === 'answer') {
                    // 실제로는 이 부분이 상대방에게 전달되어야 함
                    log('자동 응답 모드: 상대방에게 전달될 응답');
                }
            } catch (err) {
                log(`시그널링 서버 시뮬레이션 오류: ${err.message}`, 'error');
            }
        }
        
        // 수신된 시그널링 메시지 처리 (상대방으로부터)
        async function handleReceivedSignalingMessage(message) {
            try {
                if (!peerConnection) {
                    log('피어 연결이 설정되지 않았습니다.', 'error');
                    return;
                }
                
                switch (message.type) {
                    case 'offer':
                        await handleOfferMessage(message);
                        break;
                        
                    case 'answer':
                        await handleAnswerMessage(message);
                        break;
                        
                    case 'ice-candidate':
                        await handleIceCandidateMessage(message);
                        break;
                        
                    default:
                        log(`알 수 없는 시그널링 메시지 유형: ${message.type}`, 'warning');
                }
            } catch (err) {
                log(`시그널링 메시지 처리 오류: ${err.message}`, 'error');
            }
        }
        
        // SDP 오퍼 메시지 처리
        async function handleOfferMessage(message) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp));
                log('원격 오퍼 설정됨');
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                log('로컬 응답 생성됨');
                
                // 응답 전송
                sendSignalingMessage({
                    type: 'answer',
                    sdp: peerConnection.localDescription
                });
            } catch (err) {
                log(`오퍼 처리 오류: ${err.message}`, 'error');
            }
        }
        
        // SDP 응답 메시지 처리
        async function handleAnswerMessage(message) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp));
                log('원격 응답 설정됨');
                
                // 대기 중인 ICE 후보 전송
                for (const candidate of pendingCandidates) {
                    sendSignalingMessage({
                        type: 'ice-candidate',
                        candidate: candidate
                    });
                }
                
                // 후보 목록 초기화
                pendingCandidates = [];
            } catch (err) {
                log(`응답 처리 오류: ${err.message}`, 'error');
            }
        }
        
        // ICE 후보 메시지 처리
        async function handleIceCandidateMessage(message) {
            try {
                if (!message.candidate) return;
                
                await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                log('ICE 후보 추가됨');
            } catch (err) {
                log(`ICE 후보 처리 오류: ${err.message}`, 'error');
            }
        }
        
        // 연결 시작
        function startConnection() {
            const clientCode = clientCodeInput.value.trim();
            
            if (!clientCode) {
                alert('클라이언트 코드를 입력해주세요.');
                return;
            }
            
            try {
                // 내 코드 생성
                myCode = generateShortCode();
                myCodeElement.textContent = myCode;
                
                // 연결 영역 표시
                connectionArea.classList.remove('hidden');
                
                // WebRTC 연결 설정
                setupPeerConnection();
                
                // 연결 상태 업데이트
                updateConnectionStatus('connecting');
                
                log(`연결 시도 중: 클라이언트 코드 ${clientCode}, 내 코드 ${myCode}`);
            } catch (err) {
                log(`연결 시작 오류: ${err.message}`, 'error');
                alert(`연결 시작 중 오류가 발생했습니다: ${err.message}`);
                updateConnectionStatus('disconnected');
            }
        }
        
        // 연결 해제
        function disconnectConnection() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            stopFrameRateCalculation();
            stopPingInterval();
            
            isConnected = false;
            updateConnectionStatus('disconnected');
            
            // 연결 영역 숨기기
            connectionArea.classList.add('hidden');
            
            log('연결이 종료되었습니다.');
        }
        
        // 품질 설정 적용
        function applySettings() {
            if (!dataChannel || dataChannel.readyState !== 'open') {
                alert('연결이 활성화되지 않았습니다.');
                return;
            }
            
            const quality = captureQualitySelect.value;
            const rate = captureRateSelect.value;
            
            // 화질 설정 전송
            sendControlMessage({
                type: 'quality-change',
                value: quality
            });
            
            // 캡처 간격 설정 전송
            sendControlMessage({
                type: 'rate-change',
                value: rate
            });
            
            log(`설정 적용: 화질 ${quality}, 캡처 간격 ${rate}ms`, 'success');
            alert('설정이 적용되었습니다.');
        }
        
        // 화면 새로 고침 요청
        function requestRefresh() {
            if (dataChannel && dataChannel.readyState === 'open') {
                sendControlMessage({
                    type: 'restart-request',
                    timestamp: Date.now()
                });
                
                log('화면 새로고침 요청 전송');
            }
        }
        
        // 전체 화면 전환
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // 전체 화면으로 전환
                if (screenContainer.requestFullscreen) {
                    screenContainer.requestFullscreen();
                } else if (screenContainer.webkitRequestFullscreen) {
                    screenContainer.webkitRequestFullscreen();
                } else if (screenContainer.msRequestFullscreen) {
                    screenContainer.msRequestFullscreen();
                }
            } else {
                // 전체 화면 종료
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }
        
        // 사이드바 토글
        function toggleSidebar() {
            sidebar.classList.toggle('visible');
        }
        
        // 연결 버튼 이벤트
        connectBtn.addEventListener('click', startConnection);
        
        // 코드 복사 버튼 이벤트
        copyMyCodeBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(myCode)
                .then(() => {
                    alert('코드가 클립보드에 복사되었습니다.');
                })
                .catch(err => {
                    log(`복사 실패: ${err.message}`, 'error');
                    alert(`코드: ${myCode} (수동으로 복사하세요)`);
                });
        });
        
        // 연결 해제 버튼 이벤트
        disconnectBtn.addEventListener('click', disconnectConnection);
        
        // 설정 적용 버튼 이벤트
        applySettingsBtn.addEventListener('click', applySettings);
        
        // 전체 화면 버튼 이벤트
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        
        // 새로고침 버튼 이벤트
        refreshBtn.addEventListener('click', requestRefresh);
        
        // 설정 버튼 이벤트 (모바일에서 사이드바 토글)
        settingsBtn.addEventListener('click', () => {
            sidebar.classList.add('visible');
        });
        
        // 사이드바 토글 버튼 이벤트
        toggleSidebarBtn.addEventListener('click', toggleSidebar);
        
        // 클라이언트로부터 오퍼 수신 시뮬레이션 (실제로는 시그널링 서버를 통해 이루어짐)
        // 이 부분은 시뮬레이션용으로, 실제로는 서버를 통해 오퍼가 전달되어야 함
        function simulateReceivedOffer(offerData) {
            // 가상의 오퍼 생성 (실제 구현에서는 실제 상대방의 오퍼가 전달되어야 함)
            const fakeOffer = {
                type: 'offer',
                sdp: {
                    type: 'offer',
                    sdp: 'v=0\r\no=- 0 0 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\na=group:BUNDLE 0\r\n...'
                }
            };
            
            handleReceivedSignalingMessage(fakeOffer);
        }
        
        // 페이지 로드 시 초기화
        window.addEventListener('load', () => {
            // HTTPS 검사
            checkProtocol();
            
            // 모바일 여부에 따른 UI 조정
            if (isMobile) {
                sidebar.classList.remove('visible');
                toggleSidebarBtn.classList.remove('hidden');
            } else {
                sidebar.classList.add('visible');
            }
            
            // 로그 초기화
            log('화면 공유 뷰어가 초기화되었습니다.', 'success');
        });
    </script>
</body>
</html>
